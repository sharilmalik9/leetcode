{"id":971948264,"lang":"java","lang_name":"Java","time":"1 week, 6 days","timestamp":1686840337,"status":10,"status_display":"Accepted","runtime":"220 ms","url":"/submissions/detail/971948264/","is_pending":"Not Pending","title":"String Compression II","memory":"79 MB","code":"// class Solution {\n//     Integer[][][][] dp;\n//     public int getLengthOfOptimalCompression(String s, int k) {\n//         dp=new Integer[s.length()+1][s.length()+1][27][k+1];\n//        return rec(0,0,26,k,s);        \n//     }\n//     public int rec(int idx,int len,int prev,int k,String s){\n//         if(k<0){\n//             return Integer.MAX_VALUE;\n//         }\n//         if(idx>=s.length()){\n//           return 0;\n//         }\n//         if(dp[idx][len][prev][k]!=null){\n//             return dp[idx][len][prev][k];\n//         }\n//         // delete\n//         int ans=rec(idx+1,len,prev,k-1,s);\n//         //keep\n//         int cnt=0;\n//         if(s.charAt(idx)-'a'==prev){\n//             if(len==1|| len==9||len==99){\n//                 cnt++;    \n//             }\n//             ans=Math.min(ans,cnt+rec(idx+1,len+1,prev,k,s));\n//         }\n//         else{\n//             ans=Math.min(ans,1+rec(idx+1,1,s.charAt(idx)-'a',k,s));\n//         }\n//         return dp[idx][len][prev][k]=ans;    \n//     }\n\n// }\n\nclass Solution {\n    public int getLengthOfOptimalCompression(String s, int k) {\n        int n = s.length();\n        Integer[][][][] dp = new Integer[n+1][27][11][n+1]; \n\n        //currFreq size is taken 11 because in recursion we have added condition if it is graeter than 10 then make it 10 because length will be same 2.\n\n        if(n-k==100){\n            boolean is100 = true; // checking for all 100 equal chars\n\n            for(int i=1;i<n;i++){\n                if(s.charAt(i)!=s.charAt(i-1)){\n                    is100 = false;\n                }\n            }\n\n            if(is100){\n                return 4;\n            }\n        }\n\n\n\n        return f(s, 0,(char)('z'+1), 0, k, dp);\n    }\n\n    public int f(String s,int i, char prevChar,int currFreq, int k, Integer[][][][] dp) {\n        if(k<0){\n            return Integer.MAX_VALUE;\n        }\n\n       if(i==s.length()){\n           return 0;\n       }\n\n       if(currFreq>10){\n           currFreq = 10;\n       }\n\n       if(dp[i][(int)(prevChar-97)][currFreq][k]!=null){\n           return dp[i][(int)(prevChar-97)][currFreq][k];\n       }\n\n       char c = s.charAt(i);\n       int len = Integer.MAX_VALUE;\n\n       len = Math.min(len, f(s, i+1, prevChar, currFreq, k-1, dp));\n       //this is a case firstly to skip curr character and explore\n\n       if(c==prevChar){\n            if(currFreq==1 || currFreq==9){\n                len = Math.min(len, 1 + f(s, i+1, c, currFreq+1, k, dp));\n//here if length is 1 then it becomes char+length so thats why inreasing the length and if 9 the a after adding it is becoming 2 digit number then also increase the length\n            } else {\n                len = Math.min(len, f(s, i+1, c, currFreq+1, k, dp));\n//in this case we are simply increasing frequency because length will not increase\n            }\n       } else {\n           len = Math.min(len, 1 + f(s, i+1, c, 1, k, dp));\n//this is case for prevchar!= curr char so we can start curr char with freqcount as 1\n       }\n\n       return dp[i][(int)(prevChar-97)][currFreq][k] = len;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"string-compression-ii","has_notes":false}