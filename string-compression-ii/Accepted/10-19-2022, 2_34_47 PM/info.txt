{"id":825805010,"lang":"java","lang_name":"Java","time":"8 months, 1 week","timestamp":1666170287,"status":10,"status_display":"Accepted","runtime":"100 ms","url":"/submissions/detail/825805010/","is_pending":"Not Pending","title":"String Compression II","memory":"49.8 MB","code":"class Solution {\n    public int getLengthOfOptimalCompression(String s, int k) {\n        // dp[i][k]: the minimum length for s[:i] with at most k deletion.\n        int n = s.length();\n        int[][] dp = new int[110][110];\n        for (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) dp[i][j] = 9999;\n\t\t// for (int[] i : dp) Arrays.fill(i, n); // this is a bit slower (100ms)\n        dp[0][0] = 0;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 0; j <= k; j++) {                \n                int cnt = 0, del = 0;\n                for(int l = i; l >= 1; l--) { // keep s[i], concat the same, remove the different\n                    if(s.charAt(l - 1) == s.charAt(i - 1)) cnt++;\n                    else del++;\n                    if(j - del >= 0) \n                        dp[i][j] = Math.min(dp[i][j], \n                                            dp[l-1][j-del] + 1 + (cnt >= 100 ? 3 : cnt >= 10 ? 2 : cnt >= 2 ? 1: 0));\n                }\n                if (j > 0) // delete s[i]\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1]);\n            }\n        }\n        return dp[n][k];\n    }\n} ","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"string-compression-ii","has_notes":false}