{"id":751056662,"lang":"java","lang_name":"Java","time":"11 months, 2 weeks","timestamp":1658229522,"status":10,"status_display":"Accepted","runtime":"58 ms","url":"/submissions/detail/751056662/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"79.2 MB","code":"class Solution {\n  public boolean possibleBipartition(int n, int[][] dislikes) {    \n    Map<Integer, Set<Integer>> graph = buildGraph(dislikes, n);\n    UnionFind uf = new UnionFind(n);\n    \n    for(int i = 1; i < n+1; i++) {\n      Set<Integer> neighbors = graph.get(i);\n      if(neighbors.size() == 0) continue;\n      int firstNeighbor = neighbors.iterator().next(); // gets the first item in the set\n      \n      for(int neighbor : neighbors) {\n        if(uf.isConnected(i, neighbor)) return false; // if vertex i is connected with any of its neighbors, graph is not bipartite\n        uf.union(firstNeighbor, neighbor); // unionize all its neighbors\n      }\n    }\n        \n    return true;\n  }\n  \n  public Map<Integer, Set<Integer>> buildGraph(int[][] edges, int n) {\n    Map<Integer, Set<Integer>> graph = new HashMap<>();\n    \n    for(int i = 1; i < n+1; i++) graph.put(i, new HashSet<>());\n    \n    for(int[] edge : edges) {\n      int src = edge[0];\n      int dest = edge[1];\n      \n      graph.get(src).add(dest);\n      graph.get(dest).add(src);\n    }\n    \n    return graph;\n  }\n  \n  class UnionFind {\n    int[] parent;\n    int[] rank;\n    \n    public UnionFind(int n) {\n      parent = new int[n+1];\n      rank = new int[n+1];\n      \n      for(int i = 0; i < n+1; i++) {\n        parent[i] = i;\n      }\n    }\n    \n    public void union(int x, int y) {\n      int rootX = find(x);\n      int rootY = find(y);\n      \n      if(rootX != rootY) {\n        if(rank[rootX] > rank[rootY]) {\n          rank[rootX]++;\n          parent[rootY] = rootX;\n        } else {\n          rank[rootY]++;\n          parent[rootX] = rootY;\n        }\n      }\n    }\n    \n    public int find(int x) {\n      if(parent[x] == x) return x;\n      \n      int root = find(parent[x]);\n      parent[x] = root; //path compression\n      return root;\n    }\n    \n    public boolean isConnected(int x, int y) {\n      return find(x) == find(y);\n    }\n  }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"possible-bipartition","has_notes":false}