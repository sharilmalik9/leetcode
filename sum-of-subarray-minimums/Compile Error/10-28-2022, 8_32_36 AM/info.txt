{"id":831790394,"lang":"java","lang_name":"Java","time":"8Â months","timestamp":1666926156,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/831790394/","is_pending":"Not Pending","title":"Sum of Subarray Minimums","memory":"N/A","code":"class Solution {\npublic static int sumSubarrayMins(int[] arr) {\nint n = arr.length;\nDeque monoStack = new ArrayDeque<>();\n// traverse every element as the minimum value, find the left and right boundaries, and calculate the number of permutations\nint[] left = new int[n];\nint[] right = new int[n];\n\n    Arrays.fill(right, n - 1);\n    for (int i = 0; i < n; i++) {\n        while (!monoStack.isEmpty() && arr[monoStack.peek()] > arr[i]) {\n            right[monoStack.pop()] = i - 1;\n        }\n        monoStack.push(i);\n    }\n\n    monoStack.clear();\n    \n    for (int i = n - 1; i >= 0; i--) {\n        while (!monoStack.isEmpty() && arr[monoStack.peek()] >= arr[i]) {\n            left[monoStack.pop()] = i + 1;\n        }\n        monoStack.push(i);\n    }\n    long ans = 0;\n    for (int i = 0; i < n; i++) {\n        long leftCount = i - left[i];\n        long rightCount = right[i] - i;\n        ans += arr[i] * (leftCount + 1) * (rightCount + 1);\n    }\n    return (int)(ans % 1000000007);\n}\n}","compare_result":null,"title_slug":"sum-of-subarray-minimums","has_notes":false}