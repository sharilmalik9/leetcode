{"id":886427662,"lang":"java","lang_name":"Java","time":"5Â months","timestamp":1674843730,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/886427662/","is_pending":"Not Pending","title":"LRU Cache","memory":"N/A","code":"class LRUCache\n{\n    int capacity;\n    Queue<Integer> q=new ArrayDeque<>();//faster than LinkedList//to store the key according to  LRU principal\n    Map<Integer,Integer> map=new LinkedHashMap<>();//To store key and value pair \n    \n    public LRUCache(int capacity) \n    {\n        this.capacity = capacity;//cache size \n    }\n    \n    public int get(int key)\n    {\n        if (map.containsKey(key)) \n        {//cache updating \n            q.remove(key);//O(n)\n            q.offer(key);//O(1)\n            return map.get(key);//O(1)\n        } \n        else \n            return -1;//key is npt found \n    }\n    \n    public void put(int key, int value) \n    {\n        if(map.containsKey(key)) //if key is present in the map, key has to be searched and deleted and then enqueue the key into the queue, according to LRU principal\n        {\n            q.remove(key);//O(n)//remove the key from the queue \n            q.offer(key);//O(1)//apeend at the end of the queue(enqueue)\n            map.put(key,value);//O(1)//overwriding the key value (key is always unique)\n        }\n        else \n        {\n            if(q.size() < capacity)\n                q.offer(key);//inserting the new key into the queue \n            else \n            {//q.size() == capacity\n                map.remove(q.poll());//removing the least recently used key \n                q.offer(key);//qppending the new key to the queue\n            }\n            map.put(key,value);//putting the key value pair \n        }\n    }\n}","compare_result":"1111111111111111111111","title_slug":"lru-cache","has_notes":false}