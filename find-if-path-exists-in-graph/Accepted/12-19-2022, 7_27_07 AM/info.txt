{"id":861870998,"lang":"java","lang_name":"Java","time":"6 months, 1 week","timestamp":1671415027,"status":10,"status_display":"Accepted","runtime":"51 ms","url":"/submissions/detail/861870998/","is_pending":"Not Pending","title":"Find if Path Exists in Graph","memory":"122.2 MB","code":"class Solution {\n    public boolean validPath(int n, int[][] edges, int start, int end) {\n        final boolean[] visited = new boolean[n];\n        final Queue<Integer> bfsQueue = new LinkedList<Integer>();\n        bfsQueue.add(start);\n        visited[start] = true;\n        while(!bfsQueue.isEmpty()) {\n            final int currentVertex = bfsQueue.poll();\n            if(currentVertex == end) {\n                return true;\n            }\n            final Set<Integer> neighbors = findNeighbors(edges, n, currentVertex);\n            for(final int neighbor : neighbors) {\n                if(!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    bfsQueue.add(neighbor);\n                }\n            }\n        }\n        return false;\n    }\n    \n    private static Set<Integer> findNeighbors(int[][] edges, int n, int v) {\n        final Set<Integer> neighbors = new HashSet<Integer>();\n        for(int[] edge : edges) {\n            if(edge[0] == v) {\n                neighbors.add(edge[1]);\n            } else if(edge[1] == v) {\n                neighbors.add(edge[0]);\n            }\n        }\n        return neighbors;\n    }\n}","compare_result":"111111111111111111111111111","title_slug":"find-if-path-exists-in-graph","has_notes":false}