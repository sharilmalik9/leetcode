{"id":867318710,"lang":"java","lang_name":"Java","time":"6Â months","timestamp":1672292157,"status":10,"status_display":"Accepted","runtime":"235 ms","url":"/submissions/detail/867318710/","is_pending":"Not Pending","title":"Single-Threaded CPU","memory":"77.3 MB","code":"// class Solution {\n//     class pair{\n//         int idx;\n//         int start;\n//         int time;\n//         pair(int idx,int start,int time){\n//             this.idx=idx;\n//             this.start=start;\n//             this.time=time;\n//         }\n//     }\n//     public int[] getOrder(int[][] tasks){\n//         pair[] arr= new pair[tasks.length];\n//         int[] ans= new int[tasks.length];\n//         int idx=0;\n//         for(int i=0;i<tasks.length;i++){\n//             pair pp= new pair(i,tasks[i][0],tasks[i][1]);\n//             arr[i]=pp;\n//         }\n//         Arrays.sort(arr,(a,b)-> (a.start==b.start)? a.time-b.time : a.start-b.start);\n//         int time=arr[0].start;\n//         time+=arr[0].time;\n//         ans[idx]=arr[0].idx;\n//         idx++;\n//         int idx1=1;\n//         PriorityQueue<pair> pq= new PriorityQueue<>((a,b)-> (a.time==b.time) ? a.idx-b.idx : a.time-b.time);\n//         while(idx<ans.length){\n//              while(idx1<arr.length && arr[idx1].start<=time){\n//                  pq.add(arr[idx1]);\n//                  idx1++;\n//              }\n//              if(pq.size()!=0){\n//                  pair curr=pq.poll();\n//              time+=curr.time;\n//              ans[idx]=curr.idx;\n//              idx++;\n\n//              }\n//               else{\n//                   time++;\n//               }\n//         }\n//        return ans;\n//     }\n// }\nclass Solution{\npublic static int[] getOrder(int[][] tasks) {\n        int curTime = 0, i2 = 0, len = tasks.length;\n        int[] order = new int[len];\n//        Collect all the tasks with index, and sort it in order of enqueueTime (start time)\n        PriorityQueue<Task> orderedTasks = new PriorityQueue<>(Comparator.comparingInt(t -> t.start));\n        for (int i = 0; i < len; i++) {\n            orderedTasks.add(new Task(tasks[i][0], tasks[i][1], i));\n        }\n        PriorityQueue<Task> processor = new PriorityQueue<>((t1, t2) -> t1.time == t2.time ? Integer.compare(t1.idx, t2.idx) : Integer.compare(t1.time, t2.time));\n        while (!orderedTasks.isEmpty()) {\n            while (!orderedTasks.isEmpty() && orderedTasks.peek().start <= curTime) {\n                processor.add(orderedTasks.poll());\n            }\n            if (!processor.isEmpty()) {\n                Task poll = processor.poll();\n                order[i2++] = poll.idx;\n                curTime += poll.time;\n            } else {\n//                This is the key:\n//                  If the process is empty, then instead of staying ideal. Move the current time to the next task start time.\n                if (!orderedTasks.isEmpty()) curTime = orderedTasks.peek().start;\n//                Break the while loop, when there are no any new tasks that can be added to queue.\n                else break;\n            }\n        }\n//        Collect all the tasks present in processor.\n        while (!processor.isEmpty()) {\n            order[i2++] = processor.poll().idx;\n        }\n        return order;\n    }\n\n    static class Task {\n        int start, time, idx;\n\n        public Task(int start, int time, int idx) {\n            this.start = start;\n            this.time = time;\n            this.idx = idx;\n        }\n}\n}\n","compare_result":"111111111111111111111111111111111111111","title_slug":"single-threaded-cpu","has_notes":false}