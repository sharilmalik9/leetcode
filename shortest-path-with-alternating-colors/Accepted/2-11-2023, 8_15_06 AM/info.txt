{"id":895675677,"lang":"cpp","lang_name":"C++","time":"4 months, 2 weeks","timestamp":1676083506,"status":10,"status_display":"Accepted","runtime":"19 ms","url":"/submissions/detail/895675677/","is_pending":"Not Pending","title":"Shortest Path with Alternating Colors","memory":"14.6 MB","code":"enum class Color { kInit, kRed, kBlue };\n\nclass Solution {\n public:\n  vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges,\n                                       vector<vector<int>>& blueEdges) {\n    vector<int> ans(n, -1);\n    vector<vector<pair<int, Color>>> graph(n);  // graph[u] := [(v, edgeColor)]\n    queue<pair<int, Color>> q{{{0, Color::kInit}}};  // [(u, prevColor)]\n\n    for (const vector<int>& edge : redEdges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].emplace_back(v, Color::kRed);\n    }\n\n    for (const vector<int>& edge : blueEdges) {\n      const int u = edge[0];\n      const int v = edge[1];\n      graph[u].emplace_back(v, Color::kBlue);\n    }\n\n    for (int step = 0; !q.empty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        const auto [u, prevColor] = q.front();\n        q.pop();\n        ans[u] = ans[u] == -1 ? step : ans[u];\n        for (auto& [v, edgeColor] : graph[u]) {\n          if (v == -1 || edgeColor == prevColor)\n            continue;\n          q.emplace(v, edgeColor);\n          v = -1;  // Mark (u, v) as used.\n        }\n      }\n\n    return ans;\n  }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-with-alternating-colors","has_notes":false}