{"id":898735044,"lang":"java","lang_name":"Java","time":"4 months, 1 week","timestamp":1676492975,"status":10,"status_display":"Accepted","runtime":"583 ms","url":"/submissions/detail/898735044/","is_pending":"Not Pending","title":"Reverse Pairs","memory":"51.1 MB","code":"class Solution {\n    public int reversePairs(int[] nums) {\n        \n        List<Long> clone = new ArrayList<>();\n        \n        for(int n: nums) clone.add(Long.valueOf(n));\n        \n        Collections.sort(clone);\n        int n = nums.length;\n        int count = 0;\n        \n        for(int i=n-1;i>=0;i--){\n            int index = bs(clone,2*Long.valueOf(nums[i]));\n            int indexRemove = bs(clone,Long.valueOf(nums[i]));\n\t\t\t\n            if(index<=(indexRemove-1)) count += ((n-1)-index); //In case of negative numbers if index of 2*nums[i] is less than undex of nums[i]\n\t\t\telse count += (n-index);\n            clone.remove(indexRemove-1);\n            n--;\n        }\n        \n        return count;\n        \n    }\n    //Binary search\n    public int bs(List<Long> nums, Long target){\n        int l =0;\n        int h = nums.size();\n        \n        while(l<h){\n            int m = l + (h-l)/2;\n            if(nums.get(m)<=target){\n                l = m+1;\n            }else{\n                h= m;\n            }\n        }\n        \n        return l;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-pairs","has_notes":false}