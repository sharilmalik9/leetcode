{"id":919228135,"lang":"java","lang_name":"Java","time":"3 months, 1 week","timestamp":1679371854,"status":10,"status_display":"Accepted","runtime":"389 ms","url":"/submissions/detail/919228135/","is_pending":"Not Pending","title":"Shortest Path to Get All Keys","memory":"53.4 MB","code":"class Solution {\nclass Node{\n\n\tint row;\n\tint col;\n\tString key;\n\t\n\tNode(int row , int col , String key){\n\t\tthis.row = row;\n\t\tthis.col=col;\n\t\tthis.key=key;\n      }\n\t\n\tpublic String toString(int row , int col , String key) {\n\t\treturn row+\"-\"+col+\"-\"+key;\n\t\t\n\t}\n}\n\npublic int shortestPathAllKeys(String[] grid) {\n   \n     \tint rows = grid.length;\n    \tint cols = grid[0].length();\n    \t\n    \tint[][] dirs = { {1,0} , {0,1} , {0,-1} , {-1,0} };\n    \tSet<String> visited = new HashSet<>();\n    \t\n    \tint steps=0;\n    \tQueue<Node> queue = new LinkedList<>();\n    \t\n    \tint keyCount=0;\n    \t\n    \tfor(int i=0; i<rows ; i++) {\n    \t\tfor(int j=0; j < cols; j++) {\n    \t\t\tif(grid[i].charAt(j) == '@') {\n    \t\t\t\tqueue.add(new Node(i , j , \"\"));\n    \t\t\t}\n    \t\t\telse if(grid[i].charAt(j)>= 'a' && grid[i].charAt(j) <= 'f') {\n    \t\t\t\tkeyCount++;\n    \t\t\t}\n    \t\t\t\n    \t\t}\n    \t}\n    \t\n    \twhile(!queue.isEmpty()) {\n    \t\tint size = queue.size();\n    \t\tfor(int i=0; i<size; i++) {\n    \t\t    Node temp = queue.poll();\n    \t\t    int r = temp.row;\n    \t\t    int c = temp.col;\n    \t\t    String key = temp.key;\n    \t\t    if(!visited.contains(temp.toString(r , c , key)))\n    \t\t    \tvisited.add(temp.toString(r , c, key));\n    \t\t    else\n    \t\t    \tcontinue;\n    \t\t    \n    \t\t    if(key.length() == keyCount)\n    \t\t    \treturn steps;\n    \t\t    \n    \t\t    for(int[] dir : dirs) {\n    \t\t    \t\n\t\t\t\t\tint nr = r+dir[0];\n    \t\t    \tint nc = c+dir[1];\n    \t\t    \t\n    \t\t    \tNode newNode = new Node(nr , nc , key);\n    \t\t    \t\n    \t\t    \t\t\n    \t\t    \tif(nr<0 || nr>=rows || nc<0 || nc >=cols || grid[nr].charAt(nc) == '#' || visited.contains(newNode.toString(nr , nc , key))) {\n    \t\t    \t\tcontinue;\n    \t\t    \t}\n    \t\t    \t\n    \t\t    \tchar ch = grid[nr].charAt(nc);\n    \t\t    \t\n    \t\t    \t\n    \t\t    \tif(key.indexOf(ch) == -1 && ch >= 'a' &&  ch <= 'f') {\n    \t\t    \t\tqueue.add(new Node(nr , nc , key+ch));\n    \t\t    \t\t\n    \t\t    \t}\n    \t\t    \telse if( ch>='A' && ch <= 'F' && key.indexOf(Character.toLowerCase(ch)) == -1)  {\n    \t\t    \t\tcontinue;\n    \t\t    \t}\n    \t\t    \telse\n    \t\t    \t\tqueue.add(new Node(nr , nc , key));\n    \t\t    \t\t\n    \t\t    }\n    \t\t   \n    \t\t}\n    \t\t\n    \t\tsteps+=1;\n    \t\t\n    \t}\n    \t\n        return -1;\n}\n}","compare_result":"11111111111111111111111111111111111","title_slug":"shortest-path-to-get-all-keys","has_notes":false}