{"id":916616312,"lang":"java","lang_name":"Java","time":"3 months, 1 week","timestamp":1679020700,"status":10,"status_display":"Accepted","runtime":"37 ms","url":"/submissions/detail/916616312/","is_pending":"Not Pending","title":"Implement Trie (Prefix Tree)","memory":"51.7 MB","code":"/*\n\tEvery Node has a Array of 26 size to mark which chars are its children , also it has\n\ta boolean variable isEnd to mark end of any word.\n\n\tinsert(): Point to root using curr pointer, now start a loop and extract each char from the\n\tword to be inserted in TRIE,  for every char check if it is present as child of\n\tcurr node(for first char curr node will be root node).if no , then insert the char as the \n\tchild of curr and move the cur pointer to that child, so that next time we can insert\n\tthe char as its child. Do this till the end char of word and outside the for loop\n\tmark the isEnd property of curr node (i.e the last char of our word) as true;\n\n\tsearch() &  startsWith() : keep checking char by char and if you don't found your char\n\tat any point return false, else at the end check for isEnd variable (in search() fun only)\n\tand return true(in startsWith () only).\n\n\tBecause search function means that word should be completely present as a whole\n\tword and not as a part(substring ) of any other word thats why we are checking the\n\tisEnd flag , while startsWith() only want us to check that prefix is present in the trie or \n\tnot, it doesn't bother wheter we have it as a complete word or as a substring of any \n\tother word.\n*/\nclass Trie {\n    \n    class Node {\n        Node [] childs;\n        boolean isEnd;\n        \n        Node(){\n            childs = new Node[26];\n            isEnd = false;\n        }\n    }\n    \n    final private Node root;\n    \n    public Trie() {\n        root = new Node();\n    }\n    \n \n    public void insert(String word) {\n        Node curr = root;\n        \n        for(int i = 0;i<word.length();i++){\n            char ch = word.charAt(i);\n            \n            if(curr.childs[ch - 'a'] == null){\n                curr.childs[ch - 'a'] = new Node();\n            }\n            curr = curr.childs[ch - 'a'];\n        }\n        \n        curr.isEnd = true;\n    }\n    \n \n    public boolean search(String word) {\n        Node curr = root;\n        \n        for(int i = 0;i<word.length();i++){\n            char ch = word.charAt(i);\n            \n            if(curr.childs[ch - 'a'] == null) return false;\n            curr = curr.childs[ch - 'a'];\n        }\n        return curr.isEnd;\n    }\n    \n  \n    public boolean startsWith(String prefix) {\n          Node curr = root;\n        \n        for(int i = 0;i<prefix.length();i++){\n            char ch = prefix.charAt(i);\n            \n            if(curr.childs[ch - 'a'] == null) return false;\n            curr = curr.childs[ch - 'a'];\n        }\n        \n        return true;\n    }\n}","compare_result":"1111111111111111","title_slug":"implement-trie-prefix-tree","has_notes":false}