{"id":878571985,"lang":"java","lang_name":"Java","time":"5 months, 2 weeks","timestamp":1673783597,"status":10,"status_display":"Accepted","runtime":"134 ms","url":"/submissions/detail/878571985/","is_pending":"Not Pending","title":"Number of Good Paths","memory":"64.5 MB","code":"class UnionFind {\n  public UnionFind(int n) {\n    id = new int[n];\n    rank = new int[n];\n    for (int i = 0; i < n; ++i)\n      id[i] = i;\n  }\n\n  public void unionByRank(int u, int v) {\n    final int i = find(u);\n    final int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      id[i] = id[j];\n    } else if (rank[i] > rank[j]) {\n      id[j] = id[i];\n    } else {\n      id[i] = id[j];\n      ++rank[j];\n    }\n  }\n\n  public int find(int u) {\n    return id[u] == u ? u : (id[u] = find(id[u]));\n  }\n\n  private int[] id;\n  private int[] rank;\n}\n\nclass Solution {\n  public int numberOfGoodPaths(int[] vals, int[][] edges) {\n    final int n = vals.length;\n    int ans = n;\n    UnionFind uf = new UnionFind(n);\n    List<Integer>[] graph = new List[n];\n    Map<Integer, List<Integer>> valToNodes = new TreeMap<>();\n\n    for (int i = 0; i < n; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] edge : edges) {\n      final int u = edge[0];\n      final int v = edge[1];\n      if (vals[v] <= vals[u])\n        graph[u].add(v);\n      if (vals[u] <= vals[v])\n        graph[v].add(u);\n    }\n\n    for (int i = 0; i < vals.length; ++i) {\n      valToNodes.putIfAbsent(vals[i], new ArrayList<>());\n      valToNodes.get(vals[i]).add(i);\n    }\n\n    for (Map.Entry<Integer, List<Integer>> entry : valToNodes.entrySet()) {\n      final int val = entry.getKey();\n      List<Integer> nodes = entry.getValue();\n      for (final int u : nodes)\n        for (final int v : graph[u])\n          uf.unionByRank(u, v);\n      Map<Integer, Integer> rootCount = new HashMap<>();\n      for (final int u : nodes)\n        rootCount.merge(uf.find(u), 1, Integer::sum);\n      // For each group, C(count, 2) := count * (count - 1) / 2\n      for (final int count : rootCount.values())\n        ans += count * (count - 1) / 2;\n    }\n\n    return ans;\n  }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-good-paths","has_notes":false}