{"id":730695245,"lang":"java","lang_name":"Java","time":"1Â year","timestamp":1656142969,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/730695245/","is_pending":"Not Pending","title":"Find the Most Competitive Subsequence","memory":"N/A","code":"class Solution {\n    public int[] mostCompetitive(int[] nums, int k) {\n        PriorityQueue<Integer> pq= new PriorityQueue<>((a,b)->nums[a]-nums[b]);\n        int least=0;\n        for(int i=1;i<nums.length-k+1;i++){\n            if(nums[least]>nums[i]){\n                least=i;\n            }\n            \n        } \n        int[] ans= new int[k];\n        ans[0]=nums[least];\n        int start=least+1;\n        int idx=1;\n        \n        int end=nums.length-k+1;\n        least++;\n        while(least<=nums.length-k+1){\n            pq.add(least);\n            least++;\n        }\n        while(end<nums.length){\n            int curr=pq.poll();\n            while(start<curr){\n                pq.remove(start);\n                start++;\n            }\n            ans[idx]=nums[curr];\n            idx++;\n            pq.add(end);\n            end++;\n            \n            \n        }\n        return ans;\n        \n        \n    }\n}","compare_result":"1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"find-the-most-competitive-subsequence","has_notes":false}