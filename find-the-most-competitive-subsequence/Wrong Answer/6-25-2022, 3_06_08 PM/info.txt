{"id":730757989,"lang":"java","lang_name":"Java","time":"1Â year","timestamp":1656149768,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/730757989/","is_pending":"Not Pending","title":"Find the Most Competitive Subsequence","memory":"N/A","code":"class Solution {\n    public int[] mostCompetitive(int[] nums, int k) {\n       PriorityQueue<Integer> pq= new PriorityQueue<>((a,b)->nums[a]-nums[b]);\n       int start=0;\n      int end=nums.length-k;\n        for(int i=0;i<=end;i++){\n            pq.add(i);\n        }\n        int[] ans= new int[k];\n        int idx=0;\n        while(end<nums.length){\n            int curr= pq.poll();\n            ans[idx]=nums[curr];\n            idx++;\n            \n            while(start<=curr){\n                pq.remove(start);\n                start++;\n            }\n           // start++;\n            System.out.println(curr);\n            if(end<nums.length){\n                end++;\n                pq.add(end);\n            }\n            else{\n                end++;\n            }\n        }\n        return ans;\n        \n    }\n}","compare_result":"1011111111111100010100000100100000111100011000000000000000000000000000000000000000000000","title_slug":"find-the-most-competitive-subsequence","has_notes":false}