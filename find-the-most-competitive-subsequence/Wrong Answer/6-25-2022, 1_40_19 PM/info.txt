{"id":730710975,"lang":"java","lang_name":"Java","time":"1Â year","timestamp":1656144619,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/730710975/","is_pending":"Not Pending","title":"Find the Most Competitive Subsequence","memory":"N/A","code":"class Solution {\n    public int[] mostCompetitive(int[] nums, int k) {\n        if(k==0){\n            int[] check = new int[0];\n            return check;\n        }\n        PriorityQueue<Integer> pq= new PriorityQueue<>((a,b)->nums[a]-nums[b]);\n        int least=0;\n        for(int i=1;i<nums.length-k+1;i++){\n            if(nums[least]>nums[i]){\n                least=i;\n            }\n            \n        } \n        int[] ans= new int[k];\n        ans[0]=nums[least];\n        int start=least+1;\n        int idx=1;\n        \n        int end=nums.length-k+1;\n        least++;\n        while(least<=nums.length-k+1){\n            pq.add(least);\n            least++;\n        }\n        while(end<=nums.length-1&&start<=end){\n            int curr=pq.poll();\n            while(start<curr){\n                pq.remove(start);\n                start++;\n                \n            }\n           start++;\n            ans[idx]=nums[curr];\n            idx++;\n            if(end<nums.length-1){\n            end++;\n            pq.add(end);\n            }\n            else{\n                end++;\n            }\n          //  end++;\n            \n            \n        }\n        return ans;\n        \n        \n    }\n}","compare_result":"1111111111111100010100110000100000111111011000000000000000000000000000000000000000000000","title_slug":"find-the-most-competitive-subsequence","has_notes":false}