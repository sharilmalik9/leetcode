{"id":956886219,"lang":"java","lang_name":"Java","time":"1Â month","timestamp":1684994203,"status":10,"status_display":"Accepted","runtime":"27 ms","url":"/submissions/detail/956886219/","is_pending":"Not Pending","title":"Number of Great Partitions","memory":"57.5 MB","code":"class Solution {\n    public int countPartitions(int[] nums, int k) {\n        long MOD = 1000_000_007;\n        int n = nums.length;\n        long total = 0, ans = 1;\n        for (int num:nums) {\n            total += num;\n            ans = ans * 2 % MOD;// to avoid overflow\n        }\n        if (total < 2*k) return 0;\n        long[][] dp = new long[n+1][k];\n        for (int i=0;i<=n;i++) dp[i][0] = 1;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<k;j++) {\n                if (j - nums[i-1] < 0) {\n                    dp[i][j] = dp[i-1][j];\n                } else {\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j-nums[i-1]])%MOD;//to avoid overflow\n                }\n            }\n        }\n        for (int i=0;i<k;i++) {\n            ans -= dp[n][i] * 2;// the ans could be negative number\n        }\n        return (int)((ans%MOD+ MOD)%MOD);//since the ans could be negative number, so we need to add MOD\n\n    }\n}","compare_result":"111111111111111111111111111111111111111111111","title_slug":"number-of-great-partitions","has_notes":false}