{"id":741643799,"lang":"java","lang_name":"Java","time":"11 months, 3 weeks","timestamp":1657269881,"status":10,"status_display":"Accepted","runtime":"29 ms","url":"/submissions/detail/741643799/","is_pending":"Not Pending","title":"Find Eventual Safe States","memory":"74.9 MB","code":"class Solution {\n    public List<Integer> eventualSafeNodes(int[][] graph) {\n      /*\n      \n      If we observe question nearly, we first have to find the cycle and all the nodes which are included in the cycle because these are the nodes that are not safe nodes\n      \n      because from a node if we can reach to any other node which is not a terminal node then that node is not a safer node\n      \n      so we can use dfs for finding every node included in the cycle\n      \n      and return the nodes which are not a part of cylce\n      \n      */\n        \n        //create adjancey list\n        \n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        \n        int n = graph.length;\n        \n        for(int i = 0; i<n; i++){\n            adj.add(new ArrayList<Integer>());\n            for(int j = 0; j<graph[i].length; j++)\n                    adj.get(i).add(graph[i][j]);\n        }\n     \n        //for checking which node is a part of cylce\n        boolean[] cycle_nodes = new boolean[n];\n        Arrays.fill(cycle_nodes, false);\n        \n        boolean[] visited = new boolean[n];\n        Arrays.fill(visited, false);\n        \n        boolean[] dfsVisited = new boolean[n];\n        Arrays.fill(dfsVisited, false);\n        \n        \n        for(int i = 0; i<n; i++){\n            if(visited[i] == false){\n                dfsCycleCheck(i, adj, visited, dfsVisited, cycle_nodes);\n            }\n        }\n        \n        ArrayList<Integer> safeNodes = new ArrayList<Integer>();\n        \n        for(int i = 0; i<cycle_nodes.length; i++){\n            if(cycle_nodes[i] == false)\n                safeNodes.add(i);\n        }\n        \n        return safeNodes;\n    }\n    \n    private boolean dfsCycleCheck(int node, ArrayList<ArrayList<Integer>> adj, boolean[] visited, boolean[] dfsVisited, boolean[] cycleNodes){\n        visited[node] = true;\n        dfsVisited[node] = true;\n        \n        \n        for(Integer adjNode : adj.get(node)){\n            if(visited[adjNode] == false){\n                if(dfsCycleCheck(adjNode, adj, visited, dfsVisited, cycleNodes) == true)\n                    return cycleNodes[node] = true; //it shows that node is a part of cycle \n            }\n                else if(visited[adjNode] == true && dfsVisited[adjNode] == true)\n                    return cycleNodes[node] = true;\n            \n        }\n        dfsVisited[node] = false;\n        return false;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-eventual-safe-states","has_notes":false}