{"id":863165434,"lang":"java","lang_name":"Java","time":"6 months, 1 week","timestamp":1671617494,"status":10,"status_display":"Accepted","runtime":"73 ms","url":"/submissions/detail/863165434/","is_pending":"Not Pending","title":"Find Eventual Safe States","memory":"71.7 MB","code":"// do topo after reversing the entire graph (reversing all nodes and later sort it for returning correct ans)\nclass Solution {\n    public List<Integer> eventualSafeNodes(int[][] graph) {\n        List<List<Integer>> g= new ArrayList<>();\n        for(int i=0;i<graph.length;i++){\n            g.add(new ArrayList<>());\n        }\n        for(int i=0;i<graph.length;i++){\n            for(int j=0;j<graph[i].length;j++){\n                g.get(graph[i][j]).add(i);\n            }\n        }\n        int[] indegree =new int[graph.length];\n        for(int i=0;i<g.size();i++){\n            for(int j=0;j<g.get(i).size();j++){\n                indegree[g.get(i).get(j)]++;\n\n            }\n        }\n         Queue<Integer> que = new LinkedList<>();\n        for(int i=0;i<g.size();i++){\n            if(indegree[i]==0){\n                que.add(i);\n            }\n\n        }\n        List<Integer> ans= new ArrayList<>();\n        while(que.size()!=0){\n            int curr= que.poll();\n            ans.add(curr);\n\n            for(int i=0;i<g.get(curr).size();i++){\n                indegree[g.get(curr).get(i)]--;\n                if(indegree[g.get(curr).get(i)]==0){\n                    que.add(g.get(curr).get(i));\n                }\n\n                \n            }\n        }\n        Collections.sort(ans);\n        return ans;\n\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-eventual-safe-states","has_notes":false}