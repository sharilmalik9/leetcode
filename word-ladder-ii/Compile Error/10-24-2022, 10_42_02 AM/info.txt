{"id":829064143,"lang":"java","lang_name":"Java","time":"8 months, 1 week","timestamp":1666588322,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/829064143/","is_pending":"Not Pending","title":"Word Ladder II","memory":"N/A","code":"class Solution {\n  public List<List<String>> findLadders(String beginWord, String endWord, Set<String> wordList) {\n    if(wordList.contains(beginWord)) wordList.remove(beginWord);\n    List<List<String>> result = new ArrayList<>();\n    List<String> subResult = new ArrayList<>();\n    wordList.add(endWord);\n    WordLadderNode root = new WordLadderNode(0, beginWord, new ArrayList<>());\n    int[] min = new int[]{wordList.size()};\n    buildTreeBFS(beginWord, endWord, root, wordList, min);\n    searchPathDFS(root, endWord, subResult, result, min);\n    return result;\n}\n\npublic void buildTreeBFS(String beginWord, String endWord,\n                         WordLadderNode root, Set<String> wordList, int[] min) {\n    Set<String> visited = new HashSet<>();\n    visited.add(beginWord);\n    Queue<WordLadderNode> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while(!queue.isEmpty()) {\n        Queue<WordLadderNode> nextQueue = new LinkedList<>();\n        Set<String> tempVisited = new HashSet<>();\n        while(!queue.isEmpty()) {\n            WordLadderNode currNode = queue.poll();\n            int index = currNode.index;\n            for(String neighbor: getNext(currNode.name, endWord, wordList)) {\n                if(endWord.equals(neighbor)) {\n                    if(index+1 <= min[0]) {\n                        WordLadderNode temp = new WordLadderNode(index+1, neighbor, null);\n                        currNode.next.add(temp);\n                        min[0] = index+1;\n                    }\n                    continue;\n                }\n\n                if(!visited.contains(neighbor)) {\n                    tempVisited.add(neighbor);\n                    WordLadderNode temp = new WordLadderNode(index+1, neighbor, new ArrayList<>());\n                    nextQueue.offer(temp);\n                    currNode.next.add(temp);\n                }\n            }\n        }\n        visited.addAll(tempVisited);\n        queue = nextQueue;\n    }\n}\n\npublic List<String> getNext(String word, String endWord, Set<String> wordList) {\n    List<String> result = new ArrayList<>();\n    char[] wordArray = word.toCharArray();\n    for(int i=0; i<wordArray.length; i++) {\n        char old = wordArray[i];\n        for(char c='a'; c<='z'; c++) {\n            if(c == old) continue;\n            wordArray[i] = c;\n            String temp = new String(wordArray);\n            if(wordList.contains(temp)) {\n                if(endWord.equals(temp)) result.add(0, temp);\n                else result.add(temp);\n            }\n        }\n        wordArray[i] = old;\n    }\n    return result;\n}\n\npublic void searchPathDFS(WordLadderNode root, String endWord,\n                          List<String> subResult, List<List<String>> result, int[] min) {\n    if(root == null) return;\n    subResult.add(root.name);\n    if(endWord.equals(root.name)) {\n        if(root.index <= min[0]) result.add(subResult);\n        return;\n    }\n    for(WordLadderNode nextRoot: root.next) {\n        searchPathDFS(nextRoot, endWord, new ArrayList<>(subResult), result, min);\n    }\n}\n\n\nclass WordLadderNode {\n    public int index;\n    public String name;\n    public List<WordLadderNode> next;\n    public WordLadderNode(int index, String name, List<WordLadderNode> next) {\n        this.index = index;\n        this.name = name;\n        this.next = next;\n    }\n}\n}","compare_result":null,"title_slug":"word-ladder-ii","has_notes":false}