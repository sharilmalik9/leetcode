{"id":953530728,"lang":"java","lang_name":"Java","time":"1 month, 1 week","timestamp":1684523054,"status":10,"status_display":"Accepted","runtime":"1470 ms","url":"/submissions/detail/953530728/","is_pending":"Not Pending","title":"Divide Nodes Into the Maximum Number of Groups","memory":"49.2 MB","code":" class Solution {\n    public int magnificentSets(int n, int[][] edges) {\n        // bfs -> will detect odd cycle (graph must be bipartite==not have an odd cycle)\n        // for each component take the maximum\n        // dfs -> to partition into components\n        \n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int node = 1; node <= n; node++) {\n            graph.put(node, new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        Map<Integer, List<Integer>> components = new HashMap<>();\n        Set<Integer> visited = new HashSet<>();\n        int component = 1;\n        for (int node = 1; node <= n; node++) {\n            if(visited.contains(node)) continue;\n            visited.add(node);\n            components.put(component, new ArrayList<>());\n            dfsComponents(component++, node, graph, components, visited);    \n        }\n        int[] componentsMaxTravel = new int[component];\n        int finalRes = 0;\n        for(int comp = 1; comp < component; comp++) {\n            for (int compNode : components.get(comp)) {\n                \n                int compRes = bfs(compNode, graph);\n                if(compRes == -1) return -1;\n                componentsMaxTravel[comp] = Math.max(componentsMaxTravel[comp], compRes);\n            }\n            finalRes += componentsMaxTravel[comp];\n        }\n\n        return finalRes;\n        \n    }\n\n    private void dfsComponents(int component, int node, Map<Integer, List<Integer>> graph, Map<Integer, List<Integer>> components, Set<Integer> visited) {\n        components.get(component).add(node);\n        for (int neighbor : graph.get(node)) {\n            // happens when there is more than one spanning tree. I.E you can arrive at a node in more than one way\n            if(visited.contains(neighbor)) continue;\n            visited.add(neighbor);\n            dfsComponents(component, neighbor, graph, components, visited);\n        }\n    }\n\n    private int bfs(int node, Map<Integer, List<Integer>> graph) {\n        int reach = 0;\n        Set<Integer> visited = new HashSet<>();\n        Queue<Integer> queue = new LinkedList<>();\n        Set<Integer> curLevel = new HashSet<>();\n        \n        queue.offer(node);\n        visited.add(node);\n        \n        while (!queue.isEmpty()) {\n            int n = queue.size();\n            Set<Integer> nextLevel = new HashSet<>();\n\n            \n            \n            for (int i = 0; i < n; i++) {\n                int curNode = queue.poll();\n\n                for(int neighbor : graph.get(curNode)) {\n                    if(curLevel.contains(neighbor)) return -1; // Colored with different color == not bipartite\n                    if(visited.contains(neighbor)) continue;\n                    nextLevel.add(neighbor);\n                    visited.add(neighbor);\n                    queue.offer(neighbor);\n                }\n            }\n\n            curLevel = nextLevel;\n            reach++;\n        }\n        \n        return reach;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"divide-nodes-into-the-maximum-number-of-groups","has_notes":false}