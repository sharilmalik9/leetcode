{"id":750701218,"lang":"java","lang_name":"Java","time":"11 months, 2 weeks","timestamp":1658196335,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/750701218/","is_pending":"Not Pending","title":"Is Graph Bipartite?","memory":"43.3 MB","code":"class Solution {\n  public boolean isBipartite(int[][] graph) {\n    UnionFind uf = new UnionFind(graph.length);\n    for(int i = 0; i < graph.length; i++) {\n      \n      for(int j = 0; j < graph[i].length; j++) {\n        // If the node is in the same component as its neighbors, then they are in the same set and the graph is not bipartite.\n        // Bipartite means each node can only be connected to a node in another set/component\n        if(uf.isConnected(i, graph[i][j])) return false;\n        \n        // We union all the neighbors together\n        uf.union(graph[i][0], graph[i][j]);\n      }\n    }\n\n    return true;\n  }\n\n  public class UnionFind {\n    private int[] parent;\n    private int[] rank;\n\n    public UnionFind(int n) {\n      parent = new int[n];\n      rank = new int[n];\n\n      for (int i = 0; i < n; i++) {\n        parent[i] = i;\n      }\n    }\n\n    public int find(int x) {\n      if(parent[x] == x) return x;\n\n      int root = find(parent[x]);\n      parent[x] = root; // path compression\n      return root;\n    }\n\n    public void union(int x, int y) {\n      int rootx = find(x);\n      int rooty = find(y);\n\n      if (rootx == rooty) return;\n\n      if (rank[rootx] > rank[rooty]) {\n        parent[rooty] = rootx;\n        rank[rootx]++;\n      } else {\n        parent[rootx] = rooty;\n        rank[rooty]++;\n      }\n    }\n\n    public boolean isConnected(int p, int q) {\n      return find(p) == find(q);\n    }\n  }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"is-graph-bipartite","has_notes":false}