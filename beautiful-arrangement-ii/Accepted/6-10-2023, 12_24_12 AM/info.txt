{"id":967582960,"lang":"java","lang_name":"Java","time":"2 weeks, 5 days","timestamp":1686336852,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/967582960/","is_pending":"Not Pending","title":"Beautiful Arrangement II","memory":"44.3 MB","code":"class Solution {\n    public int[] constructArray(int n, int k) {\n        int[] res = new int[n];\n        \n        // [1..n-k] leave as it is, it may contains diff of 1, or contains no diff (i.e. 1 == n - k)\n        // [n-k+1..n] jump between two ends, first jump is to the right end: right -> left -> right - 1 -> left + 1\n        //            (a) each jump ensures a new diff (prev jump length - 1)\n        //            (b) x jump ensures there's x distinct diff \n        //            (c) the last jump is always 1, so same diff as [1..n-k] if any\n        //            Thus total # of distinct diff is x.  (here x = size of [n-k+1..n] = k)\n        \n        // fill out [1..n-k]\n        for (int i = 1; i <= n-k; i++) {\n            res[i-1] = i;\n        }\n        \n        boolean increasing = false;\n        int left = n - k + 1;\n        int right = n;\n        // fill out [n-k+1..n]\n        for (int pos = n - k; pos < n; pos++) {\n            if (!increasing) {\n                res[pos] = right;\n                right--;\n            } else {\n                res[pos] = left;\n                left++;\n            }\n            increasing = !increasing;\n        }\n        return res;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"beautiful-arrangement-ii","has_notes":false}