{"id":959512673,"lang":"java","lang_name":"Java","time":"1Â month","timestamp":1685355056,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/959512673/","is_pending":"Not Pending","title":"Dungeon Game","memory":"43.6 MB","code":"// my code \n// thoda togh \n// but remember tabulation of this \n\n// class Solution {\n//     int[][] dp;\n//     public int calculateMinimumHP(int[][] d) {\n//         dp= new int[d.length][d[0].length];\n//         for(int[] i:dp){\n//             Arrays.fill(i,-1);\n//         }\n//         return 1+rec(d,0,0,0);\n//     }\n//     public int rec(int[][] d,int i,int j,int pos){\n        \n       \n//         if(i==d.length-1 && j==d[0].length-1){\n//             if(d[i][j]<0 && pos<Math.abs(d[i][j])){\n//                 System.out.println(Math.abs(d[i][j])-pos);\n//               return  Math.abs(d[i][j])-pos;\n//             }\n//           //\n          \n//            // System.out.println(i+\" \"+j+ \" \"+pos);\n//             return 0;\n//         }\n//         if(i>=d.length || j>=d[0].length){\n//             return Integer.MAX_VALUE;\n//         }\n//         // if(dp[i][j]!=-1){\n//         //     return dp[i][j];\n//         // }\n//         int ans=0;\n//          if(d[i][j]<0){\n//             if(pos==0){\n//                 ans=Math.abs(d[i][j]);\n//              } \n//             else if(pos>Math.abs(d[i][j])){\n//                 pos=pos-Math.abs(d[i][j]);\n//             }\n//             else{\n//                 ans=Math.abs(Math.abs(d[i][j])-pos);\n//                 pos=0;\n//             }\n//         }\n//         else{\n//             pos+=d[i][j];\n//         }\n//         ans+=Math.min(rec(d,i+1,j,pos),rec(d,i,j+1,pos));\n//           System.out.println(i+\" \"+j+\" \" + ans);\n//        return ans;\n//     }\n// }\nclass Solution {\n    public int calculateMinimumHP(int[][] dungeon) {\n\n    // if power required to reach a cell is positive then we place zero there instead of the positive number\n   // this is to calculate the max negative number we should tackle during the path and we only take the negative value\n        int r = dungeon.length;\n        int c = dungeon[0].length;\n        int [][] dp = new int[r][c];\n        \n        for(int i= r-1; i>=0;i--)\n        {\n            for(int j= c-1; j>=0;j--)\n            {\n\t\t\t// for where the princess is located, if negative value then take the negative value else if positive then take zero\n                if(i==r-1 && j==c-1)// princess is located\n                {\n                    dp[i][j]= Math.min(0,dungeon[i][j] );\n                }\n                   // last row move right and check and follow the same process as above  i. e add the value first of the dungeon matrix first and check\n\t\t\t\t   // if positive or negative and process as above\n                else if(i== r-1) // last row\n                {\n                    dp[i][j] = Math.min(0, dungeon[i][j] + dp[i][j+1]);\n                }\n                // same as above\n                 else if(j == c-1) // last column\n                {\n                    dp[i][j] = Math.min(0, dungeon[i][j] + dp[i+1][j]);\n                }\n                // for choosing between down and right direction get the max value as we need the max negative value for the knight to safely travel\n\t\t\t\t// and process the whole as same as above \n                else \n                {\n                    dp[i][j] = Math.min(0, dungeon[i][j] + Math.max(dp[i][j+1], dp[i+1][j]));\n                }\n            \n            }\n        }\n         return Math.abs(dp[0][0]) +1;                                  \n  }\n}","compare_result":"111111111111111111111111111111111111111111111","title_slug":"dungeon-game","has_notes":false}