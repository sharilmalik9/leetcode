{"id":936663236,"lang":"java","lang_name":"Java","time":"2 months, 1 week","timestamp":1681957191,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/936663236/","is_pending":"Not Pending","title":"Maximum Width of Binary Tree","memory":"42.4 MB","code":"class Solution {\n    class Pair {\n        TreeNode node;\n        int index;\n\n        Pair(TreeNode node, int index) {\n            this.node = node;\n            this.index = index;\n        }\n    }\n\n    public int widthOfBinaryTree(TreeNode root) {\n        Queue<Pair> q = new LinkedList<>();\n        q.offer(new Pair(root, 0));\n        int maxWidth = 0;\n\n        while (!q.isEmpty()) {\n            int size = q.size();\n            int minIdx = q.peek().index;\n            int firstNodeIdx = 0, lastNodeIdx = 0;\n\n            for (int i = 0; i < size; i++) {\n                int currIdx = q.peek().index - minIdx;\n                TreeNode currNode = q.poll().node;\n\n                if (i == 0) firstNodeIdx = currIdx;\n                if (i == size - 1) lastNodeIdx = currIdx;\n\n                if (currNode.left != null) {\n                    q.offer(new Pair(currNode.left, 2 * currIdx + 1));\n                }\n                if (currNode.right != null) {\n                    q.offer(new Pair(currNode.right, 2 * currIdx + 2));\n                }\n            }\n\n            int currWidth = lastNodeIdx - firstNodeIdx + 1;\n            maxWidth = Math.max(maxWidth, currWidth);\n        }\n\n        return maxWidth;\n    }\n}\n\n// TC: O(n), SC: O(n)","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-width-of-binary-tree","has_notes":false}