{"id":925994410,"lang":"java","lang_name":"Java","time":"2 months, 4 weeks","timestamp":1680361934,"status":10,"status_display":"Accepted","runtime":"474 ms","url":"/submissions/detail/925994410/","is_pending":"Not Pending","title":"Shortest Cycle in a Graph","memory":"44.1 MB","code":"class Solution {\n    public int findShortestCycle(int n, int[][] edges) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for(int i=0;i<n;i++){\n            graph.add(new ArrayList<>());\n        }\n        for(int i=0;i<edges.length;i++){\n            graph.get(edges[i][0]).add(edges[i][1]);\n            graph.get(edges[i][1]).add(edges[i][0]);\n        }\n        \n        int ans = Integer.MAX_VALUE;\n \n        // For all vertices\n        for (int i = 0; i < n; i++)\n        {\n \n            // Make distance maximum\n            int[] dist = new int[n];\n            Arrays.fill(dist, (int) 1e9);\n \n            // Take a imaginary parent\n            int[] par = new int[n];\n            Arrays.fill(par, -1);\n \n            // Distance of source to source is 0\n            dist[i] = 0;\n            Queue<Integer> q = new LinkedList<>();\n \n            // Push the source element\n            q.add(i);\n \n            // Continue until queue is not empty\n            while (!q.isEmpty())\n            {\n \n                // Take the first element\n                int x = q.poll();\n \n                // Traverse for all it's childs\n                for (int child : graph.get(x))\n                {\n                    // If it is not visited yet\n                    if (dist[child] == (int) (1e9))\n                    {\n \n                        // Increase distance by 1\n                        dist[child] = 1 + dist[x];\n \n                        // Change parent\n                        par[child] = x;\n \n                        // Push into the queue\n                        q.add(child);\n                    } else if (par[x] != child && par[child] != x)\n                        ans = Math.min(ans, dist[x] + dist[child] + 1);\n                }\n            }\n        }\n \n        // If graph contains no cycle\n        if (ans == Integer.MAX_VALUE)\n            return -1;\n \n        // If graph contains cycle\n        else\n            return ans;\n        \n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-cycle-in-a-graph","has_notes":false}