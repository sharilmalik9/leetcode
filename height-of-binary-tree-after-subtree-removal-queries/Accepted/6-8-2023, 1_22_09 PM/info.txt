{"id":966460063,"lang":"java","lang_name":"Java","time":"2 weeks, 6 days","timestamp":1686210729,"status":10,"status_display":"Accepted","runtime":"118 ms","url":"/submissions/detail/966460063/","is_pending":"Not Pending","title":"Height of Binary Tree After Subtree Removal Queries","memory":"95.2 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    HashMap<Integer,Integer> nodeToLevel = new HashMap();\n    HashMap<Integer,Integer> nodeToDepth = new HashMap();\n    HashMap<Integer,PriorityQueue<Integer>> levelToNode = new HashMap();      \n    public int[] treeQueries(TreeNode root, int[] queries) {\n        int[] answer = new int[queries.length];  \n        findDepth(root);\n        \n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.add(root);\n        int level = 0;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b) -> nodeToDepth.get(b) - nodeToDepth.get(a));\n            while(size-- > 0){\n                TreeNode n = queue.poll();\n                if(n.left != null)\n                    queue.add(n.left);\n                if(n.right != null)\n                    queue.add(n.right);\n                pq.add(n.val);\n                nodeToLevel.put(n.val,level);\n            }\n            levelToNode.put(level,pq);\n            level++;\n        }\n\n        for(int i=0;i<queries.length;i++){\n            int levelOfQuery = nodeToLevel.get(queries[i]);\n            PriorityQueue<Integer> pq = levelToNode.get(levelOfQuery);\n            if(pq.size() == 1){\n                answer[i] = levelOfQuery - 1;\n                continue;\n            }\n            if(pq.peek() == queries[i]){\n                pq.poll();\n                answer[i] = levelOfQuery + nodeToDepth.get(pq.peek());\n                pq.add(queries[i]);          \n            }\n            else {\n                answer[i] = levelOfQuery + nodeToDepth.get(pq.peek());\n            }\n        }        \n        return answer;\n    }\n    \n    public int findDepth(TreeNode node){\n        if(node == null)\n            return 0;\n        int max = Math.max(findDepth(node.left),findDepth(node.right));\n        nodeToDepth.put(node.val,max);\n        return max+1;\n    }\n}","compare_result":"1111111111111111111111111111111111111111","title_slug":"height-of-binary-tree-after-subtree-removal-queries","has_notes":false}