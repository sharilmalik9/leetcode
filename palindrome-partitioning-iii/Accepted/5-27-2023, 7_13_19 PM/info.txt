{"id":958271466,"lang":"java","lang_name":"Java","time":"1Â month","timestamp":1685194999,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/958271466/","is_pending":"Not Pending","title":"Palindrome Partitioning III","memory":"40.5 MB","code":"class Solution {\n       //isme sbse imp h min steps to ki ek string ko palindrome bana skein\n    // uske liye vo wala ques yaad krle sharil \n    // iske dp m for every i and j k liye save ho jaayega \n    // phir bar bar calculate krne ki zaruat nhi h \n    // varna tle ajata \n    // # Faith :\n\n    // Maine apni ek string kati aur maiine ek bachi hui string ko bola ki tum apne\n    // aap ko k string mai break karke apni minChange ki value return karde. Main\n    // sabme se min value nikal ke return kardunga.\n\n    public static void minChanges(String str, int[][] dp) {\n        // YE function bilkul same hai jaise palindromic substring ki dp fill karte\n        // hain. Usko dry run kar lena, ye bhi same waise he hai.\n        int n = str.length();\n        for (int gap = 0; gap < n; gap++) {\n            for (int i = 0, j = gap; i < n && j < n; i++, j++) {\n                if (gap == 0) {\n                    dp[i][j] = 0; // har single character ek palindrome hai, to 0 changes required hai isko\n                                  // palindrome mai convert karne ke liye\n                    continue;\n                }\n\n                char ch1 = str.charAt(i);\n                char ch2 = str.charAt(j);\n\n                if (ch1 != ch2) {\n                    // Agar mere dono character equal nhi hai to mujhe\n                    // For ex : \"abbbc\" to iske liye mujhe jo beech ki string ke min changes + 1\n                    // + 1 isiliye kyunki palindrome ke liye ya to a c mai convert hoga ya c a mai.\n                    // To isiliye +1 kiya.\n                    dp[i][j] = dp[i + 1][j - 1] + 1;\n                } else {\n\n                    // Ab gar mere dono character equal hai, to mujhe palindrome mai convert karne\n                    // ke liye utne he changes chahiyein honge jitne meri beech ki string ko chahiye\n                    // honge.\n                    if (gap == 1) {\n                        dp[i][j] = 0; // for condition like \"ee\", dono character equal hai to no changes required.\n                    } else {\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                }\n            }\n        }\n    }\n\n    public int palindromePartition(String str, int k, int si, int ei, int[][] dp, int[][] minChangesDp) {\n\n        if (si == str.length()) // Agar meri string he khatam ho gyi, to answer kabhi milega he nhi.\n            return (int) 1e9;\n\n        if (str.length() - si < k) // For condition like \"abc, 5\", to abc ko 5 set mai break karna hai, which is\n                                   // not possible.\n            return (int) 1e9;\n\n        if (k == 1) // Ab agar K==1 bacha hai to sidhe uske min changes he return kardo.\n            return dp[k][si] = minChangesDp[si][ei];\n\n        if (dp[k][si] != -1)\n            return dp[k][si];\n\n        int minAns = (int) 1e9;\n        for (int cut = si; cut <= ei; cut++) {\n\n            int myStringCutValue = minChangesDp[si][cut];\n            int remainingStringValue = palindromePartition(str, k - 1, cut + 1, ei, dp, minChangesDp);\n\n            if (remainingStringValue != (int) 1e9) // Since hum chahte hain ki whi answer evaluate ho jiska answer ban\n                                                   // sakta hai. To agar remainingStringValue ki value (int)1e9 hai to\n                                                   // `uper se wali condition hit hui hai jiska matlba hai ki answer\n                                                   // create he nhi ho sakta.\n                minAns = Math.min(minAns, myStringCutValue + remainingStringValue);\n        }\n\n        return dp[k][si] = minAns;\n    }\n\n    public int palindromePartition(String str, int k) {\n        int n = str.length();\n        int[][] minChangesDp = new int[n][n];\n        minChanges(str, minChangesDp);\n\n        int[][] dp = new int[k + 1][n + 1];\n        for (int[] d : dp)\n            Arrays.fill(d, -1);\n        return palindromePartition(str, k, 0, n - 1, dp, minChangesDp);\n    }\n}","compare_result":"11111111111111111111111111111111","title_slug":"palindrome-partitioning-iii","has_notes":false}