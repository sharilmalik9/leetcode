{"id":977800411,"lang":"java","lang_name":"Java","time":"5 days, 7 hours","timestamp":1687520038,"status":10,"status_display":"Accepted","runtime":"29 ms","url":"/submissions/detail/977800411/","is_pending":"Not Pending","title":"Minimum Height Trees","memory":"54.7 MB","code":"// vv good question \n// vv good concept\nclass Solution {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        // max mht can be 2 only -why ?-you have to find the centre of the graph\n        // center can be 2 only \n        // how to find center-start from end and keep adding end elements and deleing remaining in last is the ans\n          Map<Integer, List<Integer>> graph = new HashMap<>();\n    int[] indegree = new int[n];\n    for (int[] edge : edges) {\n      int u = edge[0];\n      int v = edge[1];\n      graph.computeIfAbsent(u, k -> new ArrayList<>()).add(v);\n      graph.computeIfAbsent(v, k -> new ArrayList<>()).add(u);\n      indegree[u]++;\n      indegree[v]++;\n    }\n\n    // Find nodes with smallest incoming/outgoing edges\n    int smallestIndegree = Integer.MAX_VALUE;\n    for (int node = 0; node < n; node++)\n      smallestIndegree = Math.min(smallestIndegree, indegree[node]);\n\n    // Create a simple queue (initially used a priority queue but found it unneccesary)\n    Queue<Integer> pq = new LinkedList<>();\n    boolean[] visited = new boolean[n];\n\n    // Add all the nodes with smallest number of edges into the queue\n    // these nodes are the leaves\n    for (int node = 0; node < n; node++)\n      if (indegree[node] == smallestIndegree) {\n        pq.offer(node);\n        visited[node] = true;\n      }\n\n    List<Integer> result = new ArrayList<>();\n    while (!pq.isEmpty()) {\n      result = new ArrayList<>();\n\n      // one level of the queue will be the \"outermost\" nodes\n      // processed so far, so this \"innermost\" nodes will have longest paths\n      for (int i = 0, size = pq.size(); i < size; i++) {\n        int node = pq.poll();\n        result.add(node);\n        List<Integer> neighbors = graph.getOrDefault(node, Collections.emptyList());\n        for (int neighbor : neighbors) {\n          // when a node is processed, neighboring node will lose an edge\n          indegree[neighbor]--;\n\n          // if only one edge left for this neighbor, it is next in queue\n          if (indegree[neighbor] <= 1 && !visited[neighbor]) {\n            pq.offer(neighbor);\n            visited[neighbor] = true;\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n        \n        \n    \n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-height-trees","has_notes":false}