{"id":962095268,"lang":"java","lang_name":"Java","time":"3 weeks, 5 days","timestamp":1685682675,"status":10,"status_display":"Accepted","runtime":"28 ms","url":"/submissions/detail/962095268/","is_pending":"Not Pending","title":"K Closest Points to Origin","memory":"55.2 MB","code":"class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        //Create a priority queue that compares the second element(distance^2) from small to large \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]-b[1]);\n        //Iterate through the array to calculate the distance^2 and add it to the pq\n        for(int i = 0; i < points.length; i++){\n            int sum = points[i][0] * points[i][0] + points[i][1] * points[i][1];\n            pq.add(new int[] {i,sum});\n        }\n        //Create a new response array and poll k elements from the queue into the array\n        //That will be the k-smallest distance^2, and we don't have to do the square root necessarily\n        int[][] res = new int[k][];\n        while(k > 0){\n            res[k-1] = points[pq.poll()[0]];\n            k--;\n        }\n        return res;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"k-closest-points-to-origin","has_notes":false}